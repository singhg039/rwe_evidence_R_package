---
phase: 01-audit-trail-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - R/lineage.R
autonomous: true

must_haves:
  truths:
    - "Each data transformation is recorded as a node with parent references"
    - "trace_result() returns complete provenance chain from output to inputs"
    - "visualize_lineage() renders DAG using DiagrammeR mermaid"
    - "Lineage supports both stage-level and function-level granularity"
  artifacts:
    - path: "R/lineage.R"
      provides: "Data lineage DAG management"
      exports: ["add_lineage_node", "trace_result", "visualize_lineage", "export_lineage"]
      min_lines: 150
  key_links:
    - from: "visualize_lineage"
      to: "DiagrammeR::mermaid"
      via: "DAG rendering"
      pattern: "DiagrammeR::mermaid"
    - from: "trace_result"
      to: ".audit_env$lineage_graph"
      via: "parent traversal"
      pattern: "lineage_graph\\[\\[.*\\]\\]\\$parents"
---

<objective>
Create R/lineage.R with data lineage DAG management for tracking input-transformation-output relationships. Enables provenance queries ("show me everything that went into this result") and visualization for regulatory review.

Purpose: AUDIT-05 requires data lineage DAG tracking. This provides the query and visualization layer for understanding how results were derived.

Output: New R/lineage.R file with lineage node management, trace queries, and DAG visualization.
</objective>

<execution_context>
@C:\Users\GagandeepSingh\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\GagandeepSingh\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-audit-trail-foundation/01-RESEARCH.md
@R/logging.R
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lineage node management functions</name>
  <files>R/lineage.R</files>
  <action>
Create new file R/lineage.R with:

1. File header with roxygen documentation:
   - Package-level documentation for lineage tracking
   - @keywords internal

2. Add lineage storage to .audit_env (use same env from logging.R):
   - .audit_env$lineage_graph: named list of nodes (node_id -> node data)
   - Initialize as empty list if NULL

3. Implement `generate_node_id(prefix)`:
   - Internal function
   - Format: "{prefix}_{timestamp}_{random4chars}"
   - Ensures uniqueness within session

4. Implement `add_lineage_node(node_id = NULL, operation, parents = NULL, metadata = list(), granularity = c("stage", "function"))`:
   - Auto-generate node_id if NULL
   - granularity parameter: "stage" (default) or "function"
   - Create node structure:
     - node_id
     - operation (string describing the transformation)
     - timestamp (Sys.time())
     - parents (character vector of parent node_ids, NULL for root nodes)
     - metadata (list with operation-specific details)
     - granularity
   - Store in .audit_env$lineage_graph[[node_id]]
   - Return node_id invisibly

5. Implement `get_lineage_node(node_id)`:
   - Retrieve node from lineage graph
   - Error if not found

6. Implement `init_lineage()`:
   - Initialize lineage graph if not exists
   - Called automatically by add_lineage_node

Export: add_lineage_node, get_lineage_node
Internal: generate_node_id, init_lineage
  </action>
  <verify>
Run in R:
```r
source("R/lineage.R")
id1 <- add_lineage_node(operation = "data_ingestion", metadata = list(source = "file.csv"))
id2 <- add_lineage_node(operation = "harmonization", parents = id1, metadata = list(target = "OMOP"))
get_lineage_node(id2)  # Should show parents = id1
```
  </verify>
  <done>
- add_lineage_node() creates nodes with parent references
- Nodes stored in .audit_env$lineage_graph
- Auto-generated unique node_ids
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement trace_result provenance query</name>
  <files>R/lineage.R</files>
  <action>
Add to R/lineage.R:

1. Implement `trace_result(node_id)`:
   - Breadth-first traversal backwards through parents
   - Track visited nodes to avoid cycles (defensive)
   - For each node, record:
     - level (0 = target node, increasing = further back)
     - operation
     - timestamp
     - metadata
   - Return data frame with columns: node_id, level, operation, timestamp
   - Class: c("rwe_lineage_trace", "data.frame")

2. Implement `print.rwe_lineage_trace(x, ...)`:
   - Print formatted trace output:
     - "=== Data Lineage Trace ==="
     - "Final Result: {node_id}"
     - "Trace Depth: {N} levels"
     - List nodes by level with operation and timestamp

3. Implement `get_root_nodes()`:
   - Return all nodes with no parents (data sources)
   - Useful for understanding what inputs a study started with

4. Implement `get_leaf_nodes()`:
   - Return all nodes that are not parents of any other node
   - Represents final outputs

Export: trace_result, get_root_nodes, get_leaf_nodes
S3method: print.rwe_lineage_trace
  </action>
  <verify>
Run in R:
```r
# Build a simple DAG
id1 <- add_lineage_node(operation = "data_ingestion")
id2 <- add_lineage_node(operation = "data_ingestion_2")
id3 <- add_lineage_node(operation = "merge", parents = c(id1, id2))
id4 <- add_lineage_node(operation = "analysis", parents = id3)

trace <- trace_result(id4)
print(trace)  # Should show all 4 nodes at different levels
get_root_nodes()  # Should return id1, id2
get_leaf_nodes()  # Should return id4
```
  </verify>
  <done>
- trace_result() traverses full provenance chain
- Returns structured data frame with levels
- get_root_nodes/get_leaf_nodes identify DAG boundaries
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement DAG visualization and export</name>
  <files>R/lineage.R</files>
  <action>
Add to R/lineage.R:

1. Implement `visualize_lineage(root_node_id = NULL, format = c("mermaid", "graphviz"))`:
   - If root_node_id NULL, visualize entire graph
   - If root_node_id provided, visualize subgraph reachable from that node
   - Build edge list from parent references
   - For mermaid format:
     - Generate: "graph LR\n" + edges as "parent --> child"
     - Node labels: "{node_id}[{operation}]"
     - Call DiagrammeR::mermaid(spec)
   - For graphviz format:
     - Generate DOT format
     - Call DiagrammeR::grViz(spec)
   - Return DiagrammeR widget invisibly

2. Implement `export_lineage(file, format = c("dot", "json", "yaml"))`:
   - dot: Export graph in DOT format for Graphviz tools
   - json: Export lineage_graph as JSON
   - yaml: Export lineage_graph as YAML
   - Include session metadata (timestamp, R version)

3. Implement `lineage_to_mermaid()`:
   - Internal helper
   - Convert lineage_graph to mermaid specification string
   - Handle node styling based on granularity (stage vs function)

4. Add @importFrom DiagrammeR mermaid grViz

Export: visualize_lineage, export_lineage
  </action>
  <verify>
Run in R:
```r
# Using DAG from Task 2
visualize_lineage()  # Should render interactive mermaid diagram

# Export tests
export_lineage("lineage.dot", format = "dot")
export_lineage("lineage.json", format = "json")
# Files should contain valid DOT/JSON
```
  </verify>
  <done>
- visualize_lineage() renders interactive DAG with DiagrammeR
- export_lineage() produces DOT, JSON, YAML formats
- Visualization supports both full graph and subgraph views
  </done>
</task>

</tasks>

<verification>
1. `R CMD check --no-manual` passes (new file integrates correctly)
2. Manual verification:
   - Build multi-node DAG
   - trace_result() returns complete chain
   - visualize_lineage() shows correct graph structure
   - Exported DOT file validates in Graphviz
</verification>

<success_criteria>
1. add_lineage_node() creates nodes with parent references
2. trace_result() returns complete provenance from any output back to inputs
3. visualize_lineage() renders DAG using DiagrammeR mermaid
4. export_lineage() produces valid DOT, JSON, and YAML formats
5. Both stage-level and function-level granularity supported
</success_criteria>

<output>
After completion, create `.planning/phases/01-audit-trail-foundation/01-02-SUMMARY.md`
</output>
