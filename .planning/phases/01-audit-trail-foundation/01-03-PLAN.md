---
phase: 01-audit-trail-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - R/audit_capture.R
  - R/logging.R
autonomous: true

must_haves:
  truths:
    - "All delegated package calls (WeightIt, cobalt, MatchIt, admiral) are captured in audit trail"
    - "Each audit entry includes package name, version, function, parameters, duration"
    - "Warnings and errors from delegated packages are captured in audit entries"
    - "Audit trail exports to JSON and YAML with verification"
  artifacts:
    - path: "R/audit_capture.R"
      provides: "Delegated package call wrapper"
      exports: ["audit_delegated_call"]
      min_lines: 100
    - path: "R/logging.R"
      provides: "Extended export function with verification"
      contains: "export_audit_trail_verified"
  key_links:
    - from: "audit_delegated_call"
      to: "append_audit_entry"
      via: "audit trail append"
      pattern: "append_audit_entry\\(entry\\)"
    - from: "audit_delegated_call"
      to: "withCallingHandlers"
      via: "warning/error capture"
      pattern: "withCallingHandlers.*tryCatch"
    - from: "export_audit_trail_verified"
      to: "verify_audit_chain"
      via: "pre-export verification"
      pattern: "verify_audit_chain"
---

<objective>
Create R/audit_capture.R with delegated package call wrapper that captures full context (timestamp, package, version, parameters, duration, warnings, errors) and extend R/logging.R export functions with hash chain verification.

Purpose: AUDIT-01 and AUDIT-02 require capturing all delegated calls with full metadata. AUDIT-04 requires verified export. This plan implements the capture wrapper used by all subsequent statistical delegation phases.

Output: New R/audit_capture.R and extended export_audit_trail with verification.
</objective>

<execution_context>
@C:\Users\GagandeepSingh\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\GagandeepSingh\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-audit-trail-foundation/01-RESEARCH.md
@.planning/phases/01-audit-trail-foundation/01-01-SUMMARY.md
@R/logging.R
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create delegated package call wrapper</name>
  <files>R/audit_capture.R</files>
  <action>
Create new file R/audit_capture.R with:

1. File header with roxygen documentation:
   - Description of delegated call auditing
   - @importFrom utils packageVersion

2. Implement `audit_delegated_call(package, func_name, func, args, operation_name, lineage_parents = NULL)`:
   - Core wrapper function for all external package calls
   - Parameters:
     - package: package name (string, e.g., "WeightIt")
     - func_name: function name (string, e.g., "weightit")
     - func: actual function to call
     - args: list of arguments to pass
     - operation_name: descriptive name for audit log
     - lineage_parents: optional parent node_ids for lineage tracking
   - Implementation:
     a. Record start_time <- Sys.time()
     b. Get pkg_version <- as.character(packageVersion(package))
     c. Initialize warnings_captured <- character()
     d. Initialize errors_captured <- character()
     e. Execute with withCallingHandlers + tryCatch:
        - tryCatch for errors: capture message, re-throw
        - withCallingHandlers for warnings: capture message, muffle warning
     f. Record end_time, compute duration_ms
     g. Build entry list:
        - operation: operation_name
        - timestamp: ISO 8601 format
        - package: package name
        - version: pkg_version
        - function_name: func_name
        - params: sanitize_params(args) (see below)
        - duration_ms: rounded
        - warnings: warnings_captured
        - errors: errors_captured
        - success: TRUE if no errors
     h. Call append_audit_entry(entry)
     i. Optionally add lineage node if lineage_parents provided
     j. Return result

3. Implement `sanitize_params(params)`:
   - Internal function
   - For each param:
     - If data.frame/matrix: {type, nrow, ncol, hash=digest(x)}
     - If formula: deparse to string
     - If function: "function"
     - If atomic scalar/small vector (<100 elements): as-is
     - If large vector: {type, length, hash}
     - If list: recurse
   - Prevents huge objects in audit trail per research pitfall

4. Implement `summarize_large_object(x)`:
   - Internal helper for sanitize_params
   - Returns summary with type, dimensions, hash

Export: audit_delegated_call
Internal: sanitize_params, summarize_large_object
  </action>
  <verify>
Run in R:
```r
source("R/audit_capture.R")
source("R/logging.R")
init_audit_session()

# Test with a simple function
result <- audit_delegated_call(
  package = "base",
  func_name = "mean",
  func = mean,
  args = list(x = 1:10),
  operation_name = "test_mean"
)
# result should be 5.5
# Audit file should have entry with package="base", function_name="mean"
```
  </verify>
  <done>
- audit_delegated_call() wraps any function with full audit capture
- Warnings and errors captured in audit entry
- Large parameters sanitized to prevent bloated audit files
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend export_audit_trail with verification</name>
  <files>R/logging.R</files>
  <action>
Add to R/logging.R (extending existing export_audit_trail):

1. Implement `export_audit_trail_verified(format = c("json", "yaml"), output_dir = ".", pdf = FALSE, verify = TRUE)`:
   - More robust version of existing export_audit_trail
   - Parameters:
     - format: "json" or "yaml"
     - output_dir: where to write files
     - pdf: whether to generate PDF summary (placeholder for now)
     - verify: whether to verify hash chain before export (default TRUE)
   - Implementation:
     a. Get current session audit file
     b. If verify=TRUE:
        - Call verify_audit_chain()
        - If not valid, stop with error message including broken_at location
     c. Read all JSONL lines, parse to list
     d. Generate output filename: audit_trail_{timestamp}.{format}
     e. Export using jsonlite::write_json or yaml::write_yaml
     f. Export session_info.txt alongside:
        - Call sessioninfo::session_info()
        - Write capture.output() to file
     g. Log export completion
     h. Return list(audit_file, session_file, verification_result) invisibly

2. Update existing export_audit_trail() to add deprecation warning pointing to export_audit_trail_verified

3. Implement `get_audit_summary()`:
   - Returns summary statistics of current audit session:
     - entry_count
     - operations (unique operation names)
     - packages_used (unique packages)
     - total_duration_ms
     - warning_count
     - error_count
     - time_range (first to last timestamp)

Export: export_audit_trail_verified, get_audit_summary
  </action>
  <verify>
Run in R:
```r
# After adding some audit entries
export_audit_trail_verified(format = "json", output_dir = tempdir())
# Should create audit_trail_*.json and audit_trail_*_session_info.txt
# Both files should exist and be valid

get_audit_summary()
# Should return summary statistics
```
  </verify>
  <done>
- export_audit_trail_verified() exports with hash chain verification
- Session info exported alongside audit trail
- get_audit_summary() provides session statistics
  </done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for audit capture</name>
  <files>tests/testthat/test-audit_capture.R</files>
  <action>
Create tests/testthat/test-audit_capture.R with tests:

1. test_that("audit_delegated_call captures basic metadata"):
   - Call with mock function
   - Read audit file, parse last entry
   - Verify: operation, package, version, function_name, duration_ms present

2. test_that("audit_delegated_call captures warnings"):
   - Create function that generates warning
   - Wrap with audit_delegated_call
   - Verify warnings array in audit entry contains warning text

3. test_that("audit_delegated_call captures errors"):
   - Create function that throws error
   - Wrap with expect_error(audit_delegated_call(...))
   - Verify errors array in audit entry contains error text
   - Verify success = FALSE

4. test_that("sanitize_params handles large data frames"):
   - Create 10000 row data frame
   - Call sanitize_params
   - Verify result contains nrow, ncol, hash, not full data

5. test_that("export_audit_trail_verified creates valid JSON"):
   - Add entries
   - Export to JSON
   - Read back with jsonlite::read_json
   - Verify structure matches original entries

6. test_that("export_audit_trail_verified fails on tampered file"):
   - Add entries
   - Manually tamper with audit file
   - Expect export_audit_trail_verified to error

7. test_that("get_audit_summary returns correct counts"):
   - Add known number of entries
   - Call get_audit_summary()
   - Verify entry_count, packages_used, etc.
  </action>
  <verify>Run `testthat::test_file("tests/testthat/test-audit_capture.R")` - all tests pass</verify>
  <done>7 unit tests covering metadata capture, warning/error capture, parameter sanitization, export verification, and summary statistics</done>
</task>

</tasks>

<verification>
1. `R CMD check --no-manual` passes
2. `testthat::test_dir("tests/testthat")` passes all tests
3. Integration test:
   - Init session
   - Make several audit_delegated_call() calls
   - Export to JSON and YAML
   - Both files contain complete audit trail with hash chain
   - Session info file created alongside
</verification>

<success_criteria>
1. audit_delegated_call() captures package, version, function, params, duration for any wrapped call
2. Warnings from wrapped calls captured in audit entry
3. Errors from wrapped calls captured before re-throwing
4. Large parameters summarized (hash + dimensions) not serialized fully
5. export_audit_trail_verified() verifies hash chain before export
6. Exports include session_info.txt with full R environment details
7. All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-audit-trail-foundation/01-03-SUMMARY.md`
</output>
