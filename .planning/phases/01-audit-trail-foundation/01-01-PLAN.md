---
phase: 01-audit-trail-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - R/logging.R
  - DESCRIPTION
autonomous: true

must_haves:
  truths:
    - "Audit session creates unique JSONL file with PID+UUID suffix"
    - "Each audit entry includes prev_hash linking to previous entry"
    - "Hash chain verification detects any modification to audit trail"
    - "Write buffer handles file system failures gracefully"
  artifacts:
    - path: "R/logging.R"
      provides: "Extended audit trail with JSONL format and hash chain"
      contains: "init_audit_session"
    - path: "R/logging.R"
      provides: "Hash chain append function"
      contains: "append_audit_entry"
    - path: "R/logging.R"
      provides: "Hash chain verification"
      contains: "verify_audit_chain"
    - path: "DESCRIPTION"
      provides: "New dependencies"
      contains: "digest"
  key_links:
    - from: "append_audit_entry"
      to: "digest::digest"
      via: "SHA256 hash computation"
      pattern: "digest::digest.*sha256"
    - from: "init_audit_session"
      to: ".audit_env"
      via: "environment storage"
      pattern: "\\.audit_env\\$audit_file"
---

<objective>
Extend R/logging.R with immutable JSONL audit trail infrastructure including per-session files, SHA256 hash chains for tamper-evidence, and buffered writes for reliability.

Purpose: Establishes the foundational audit storage layer that all subsequent audit capture will use. Hash chains provide 21 CFR Part 11 compliant tamper-evidence.

Output: Extended logging.R with session management, JSONL append, hash chain, and verification functions.
</objective>

<execution_context>
@C:\Users\GagandeepSingh\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\GagandeepSingh\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-audit-trail-foundation/01-RESEARCH.md
@R/logging.R
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add digest and sessioninfo dependencies</name>
  <files>DESCRIPTION</files>
  <action>
Add digest and sessioninfo to DESCRIPTION Imports section:
- digest (>= 0.6.37) - for SHA256 hash chain
- sessioninfo (>= 1.2.3) - for enhanced session info capture

These are currently missing from DESCRIPTION but required per research findings.
Move jsonlite from Suggests to Imports as it's now required for core audit functionality.
  </action>
  <verify>Check DESCRIPTION has digest, sessioninfo in Imports; Run `R CMD check --no-manual` passes dependency resolution</verify>
  <done>DESCRIPTION includes digest >= 0.6.37 and sessioninfo >= 1.2.3 in Imports</done>
</task>

<task type="auto">
  <name>Task 2: Implement audit session management and hash chain</name>
  <files>R/logging.R</files>
  <action>
Add to R/logging.R (after existing .logger_env):

1. Create `.audit_env` environment for session state:
   - audit_file: current session JSONL file path
   - write_buffer: list of entries pending write (for failure recovery)
   - last_hash: cached hash of last entry

2. Implement `init_audit_session()`:
   - Generate unique filename: `audit_YYYYMMDD_HHMMSS_<PID>_<UUID>.jsonl`
   - UUID from digest::digest(runif(1)) first 8 chars
   - Create audit directory in tempdir()/rwevidence_audit/ (not inst/ - runtime data)
   - Write genesis entry with prev_hash = "0000000000000000"
   - Capture full sessioninfo::session_info() in genesis entry
   - Return audit file path invisibly

3. Implement `get_session_audit_file()`:
   - Auto-initialize session if not exists
   - Return current audit file path

4. Implement `append_audit_entry(entry)`:
   - Get prev_hash from .audit_env$last_hash (faster than re-reading file)
   - Add prev_hash to entry
   - Compute current_hash using digest::digest(toJSON(entry without current_hash), algo="sha256")
   - Add current_hash to entry
   - Attempt write with cat(toJSON, "\n", file=, append=TRUE)
   - On write failure: add to .audit_env$write_buffer, attempt flush later
   - Update .audit_env$last_hash
   - Return entry invisibly

5. Implement `verify_audit_chain(audit_file = NULL)`:
   - Default to current session file
   - Read all lines, parse JSON
   - For each entry after first: verify prev_hash matches prior entry's current_hash
   - Return list(valid=TRUE/FALSE, entries=N, broken_at=NULL or line number, message=)

6. Implement `flush_audit_buffer()`:
   - Internal function called periodically
   - Attempt to write buffered entries
   - Remove successfully written entries from buffer

Add @importFrom directives: digest::digest, sessioninfo::session_info, jsonlite::toJSON, jsonlite::fromJSON

Export: init_audit_session, get_session_audit_file, append_audit_entry, verify_audit_chain
  </action>
  <verify>
Run in R:
```r
library(rwevidence)
init_audit_session()
# Should create file in tempdir()/rwevidence_audit/
append_audit_entry(list(operation="test", data="value"))
append_audit_entry(list(operation="test2", data="value2"))
verify_audit_chain()  # Should return valid=TRUE
```
  </verify>
  <done>
- init_audit_session() creates uniquely-named JSONL file with genesis entry
- append_audit_entry() adds hash-chained entries
- verify_audit_chain() validates hash chain integrity
- Write buffer handles failures gracefully
  </done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for audit infrastructure</name>
  <files>tests/testthat/test-audit_chain.R</files>
  <action>
Create tests/testthat/test-audit_chain.R with tests:

1. test_that("init_audit_session creates unique file"):
   - Call init_audit_session()
   - Verify file exists
   - Verify filename contains PID
   - Verify genesis entry has prev_hash = "0000000000000000"

2. test_that("append_audit_entry creates hash chain"):
   - Add 3 entries
   - Read file, parse lines
   - Verify each entry[i].prev_hash == entry[i-1].current_hash

3. test_that("verify_audit_chain detects tampering"):
   - Add entries, verify passes
   - Manually modify file (change a value)
   - Verify verify_audit_chain() returns valid=FALSE

4. test_that("concurrent sessions create separate files"):
   - Reset .audit_env
   - Create session 1, note filename
   - Reset .audit_env
   - Create session 2, note filename
   - Verify filenames differ

5. test_that("write buffer recovers from failure"):
   - Mock write failure
   - Verify entry added to buffer
   - Verify flush_audit_buffer attempts retry
  </action>
  <verify>Run `testthat::test_file("tests/testthat/test-audit_chain.R")` - all tests pass</verify>
  <done>5 unit tests covering session creation, hash chain, tampering detection, concurrency, and buffer recovery</done>
</task>

</tasks>

<verification>
1. `R CMD check --no-manual` passes (no dependency errors)
2. `testthat::test_dir("tests/testthat")` passes all new and existing tests
3. Manual verification:
   - Create session, add entries, verify chain
   - Manually corrupt file, verify detection
</verification>

<success_criteria>
1. DESCRIPTION includes digest and sessioninfo in Imports
2. init_audit_session() creates unique JSONL file with genesis entry
3. append_audit_entry() creates cryptographically-linked entries
4. verify_audit_chain() detects any modification to audit trail
5. Write buffer prevents data loss on filesystem failures
6. All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-audit-trail-foundation/01-01-SUMMARY.md`
</output>
